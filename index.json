[{"content":"Hey folks, This is the introductory chapter on a series of blogs on how you can build a database from scratch by yourself.\nBut Why? Why build a database, you ask? There\u0026rsquo;s plenty already. And I only care about the CRUD stuff.\nUmm, I guess most of us treat a database as a black box and dump stuff into it. But we only care about some of it if we get a connection pool failure alert on our pager. We dig a bit and then tune it to fix it there. But, to really make the most of your database and most importantly the way you decide if the task requires you to use a SQL or NoSQL one, you gotta see what\u0026rsquo;s the real difference in the two.\nThis can only happen if you have built one.\nSome Background I\u0026rsquo;ve always wanted to learn how a database actually works under the hood. Two things really intrigued me:\nWhat the actual INSERT command does. I assumed it must finally be doing some sort of a file.Write() somewhere. Why are there so many databases out there. What\u0026rsquo;s the fight about SQL vs NoSQL vs Columnar Storage vs KV store. What\u0026rsquo;s the actual difference between an OLTP and an OLAP. I finally decided to dig deep into the internals of it, and bought two books:\nDesigning Data-Intensive Applications by Martin Kleppmann: https://www.oreilly.com/library/view/designing-data-intensive-applications/9781491903063/ Database Internals by Alex Petrov: https://www.oreilly.com/library/view/database-internals/9781492040330/ Watched a lot of CMU videos: https://www.youtube.com/watch?v=df-l2PxUidI\u0026amp;list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf\u0026amp;index=3\u0026amp;ab_channel=CMUDatabaseGroup\nBut at one point, when I started getting bored with the theory, I put my foot down and decided to build one.\nHow hard could it be, I thought! Well, very much!\nThe rest of this article is about what really goes inside building a database system. There are a lot of moving parts, all of which work in harmony with each other to finally give you that simple API of db.put(\u0026lt;key\u0026gt;, \u0026lt;value\u0026gt;).\nLet\u0026rsquo;s see the components of the most popular database, MySQL:\nLooking at it, we have the following components:\nDB Connectors/Client SQL Interface API SQL Parser Query Optimizer Buffer Pools Storage Engines (InnoDB, MyRocks, MyISAM) File System That\u0026rsquo;s a lot of things under the hood, each with their own share of complexity.\nI decided to break this down in a bottom-up fashion, and decided to first understand how the actual data is stored in the end. It must be something, right? Some sort of array maybe or a hashmap or some kind of data structure, right? But how do you store that on a file??\nThing is, you need a disk-backed data structure to efficiently store data on disk. And all of us mostly use the in-memory structures like BSTs, Hashmaps, Sets. That stuff is not really meant for disk usage because of a lot of reasons!\nSince you got to have your database the fastest component in your system, because at the end of it, your API is going to call the database to store/retrieve, you need to use some DS that allows you to store data efficiently so that further reads can make the most of it.\nThere are some pre-requisites and theory/primer that you need to understand to move forward. I have attached some references for you to look at:\nHow Disks work (HDDs, SSDs) Understand disk-access patterns. Mainly, why Sequential i/o is better than random i/o Handling power failures to have Integrity semantics Disk-based data structures like B-Tree, B+ Trees, LSM Understanding Pages and Blocks at the OS level. File Formats (CSV, Parquet, etc). Essentially, Encoding and Compression techniques Now that we know a bit about everything, we can dig into the code of the most famous database on the planet: SQLite\nHere\u0026rsquo;s a reader-friendly version to analyse parts of it: https://github.com/davideuler/SQLite-2.5.0-for-code-reading\nI have worked with Maxwell/Debezium, which are tools that let you replicate databases. I thought, where else to start than reading about this binlog stuff itself.\nWait, what\u0026rsquo;s this Binlog?\nEssentially, when you issue any query to a database, the engine first writes the command that it is going to do on a structure append-only log file. Then it issues the command (SELECT/INSERT or any command). It does so to have I (Integrity) in the ACID that it guarantees.\nIn case the db operation, let\u0026rsquo;s say the INSERT fails for some reason, because of disk corruption or power failures or data center floodings, it can replay the action by reading from the log file that it had previously written to.\nThis is what we call in database terms, a Write-Ahead-Log (WAL) mechanism.\nHere\u0026rsquo;s some Postgres theory on it: https://www.postgresql.org/docs/current/wal-intro.html\nI took the liberty to write this on my own:\nHere\u0026rsquo;s my naive implementation of a WAL: https://github.com/stym06/rebuf And the accompanying HN post: https://news.ycombinator.com/item?id=40908178\nI wrote this to understand how a simple thing like logging can be so complex, and can be so thoughtfully built.\nThe next blog will be a deep dive on the actual implementation of the WAL.\nTill then, Bye.\nStay Curious!\n","permalink":"https://stym06.github.io/posts/build-a-db-from-scratch/","summary":"Hey folks, This is the introductory chapter on a series of blogs on how you can build a database from scratch by yourself.\nBut Why? Why build a database, you ask? There\u0026rsquo;s plenty already. And I only care about the CRUD stuff.\nUmm, I guess most of us treat a database as a black box and dump stuff into it. But we only care about some of it if we get a connection pool failure alert on our pager.","title":"Building a Database From Scratch 💾"},{"content":"The world works on distributed systems, and if there is one thing that is always happening is routing of requests. Be it how your Instagram posts go to that specific data-center or how the IPL matches being streamed are coming to us from which one of the global CDNs, all of this is a matter of effective choice of request-\u0026gt;server mapping essentially.\nWe have load balancers which do some of this. They try to route the incoming requests to one of the available servers in many of the available algorithms. We have distributed clusters of databases and servers all trying to do the same thing.\nWonder what they are using?\nConsistent Hashing.\nWait, what\u0026rsquo;s Hashing, first of all, and Consistent at that?\nLet\u0026rsquo;s dive in!\nLet\u0026rsquo;s say you have a bunch of keys you want to store and retrieve and you have a bunch of servers as well. For consistency, let\u0026rsquo;s assume we have 10 keys and only 3 servers\nWe can store these keys randomly, but we won\u0026rsquo;t be able to deterministically say which one of the server did my key go to, right? Ok, so we can store them in a round-robin fashion, sounds cool? Or cooler, we can encode the data into 8-bit and take the modulo of 3, so that we get a number betwen [1 -\u0026gt; 3], which gives us a server name. And since the encoding is also fixed, on retrieval of the key, we can again encode it, get the server name and do a fetch request for our key.\nAll fun till now. This works, Yes.\nBut imagine, if Server-2 goes down. We will have to move all our keys to one of the remaining ones, right? Or let\u0026rsquo;s say someone else also wants to send keys, we might need to add more servers. Well, for uniformity, we would need to relocate most of our keys to this new shiny server.\nTurns out this data movement operation will take all the time when doing upscaling and downnscaling. What\u0026rsquo;s a better way then?\nEnter Consistent Hashing!\nHere, we dont do the modulo thing to get the server id, but what we do is have a giant hash space where our servers reside with their hashkeys. And now, not taking the hash-collision approach of going to the index, we hash our key, and take a stroll to the right to find the first available hash. If we find it, that\u0026rsquo;s our server!\nLet\u0026rsquo;s implement this.\nOne way to implement this is using arrays and going to the right side of the array, but that takes O(n) in the worst case, so we just create a Sorted Map.\npublic class ConsistentHashing { private final MessageDigest md; private final TreeMap\u0026lt;Long, String\u0026gt; circle; private final int numReplicas; public ConsistentHashing(int numReplicas) throws NoSuchAlgorithmException { this.numReplicas = numReplicas; this.md = MessageDigest.getInstance(\u0026#34;SHA-256\u0026#34;); this.circle = new TreeMap\u0026lt;\u0026gt;(); } public void addServer(String key) { for(int i = 0; i \u0026lt; numReplicas; i++) { Long hash = generateHash(key + i); circle.put(hash, key); } } public void removeServer(String key) throws Exception { for(int i = 0; i \u0026lt; numReplicas; i++) { Long hash = generateHash(key + i); circle.remove(hash); } } public String getServer(String key) throws Exception { Long hash = generateHash(key); SortedMap\u0026lt;Long, String\u0026gt; tailMap = circle.tailMap(hash); Long firstServerTotheRightKey = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey(); return circle.get(firstServerTotheRightKey); } private long generateHash(String key) { md.reset(); md.update(key.getBytes()); byte[] digest = md.digest(); long hash = ((long) (digest[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((long) (digest[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((long) (digest[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((long) (digest[0] \u0026amp; 0xFF)); return hash; } public static void main(String[] args) throws Exception { ConsistentHashing consistentHashing = new ConsistentHashing(10); //add servers and keys final List\u0026lt;String\u0026gt; servers = List.of(\u0026#34;s1\u0026#34;, \u0026#34;s2\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;s4\u0026#34;, \u0026#34;s5\u0026#34;); for(String server: servers) { consistentHashing.addServer(server); } //key for k1 System.out.println(\u0026#34;Current location of k1 is \u0026#34; + consistentHashing.getServer(\u0026#34;k1\u0026#34;)); //remove server s5 System.out.println(\u0026#34;Removing server s5\u0026#34;); consistentHashing.removeServer(\u0026#34;s5\u0026#34;); //key for k1 System.out.println(\u0026#34;New location of k1 is \u0026#34; + consistentHashing.getServer(\u0026#34;k1\u0026#34;)); } } ","permalink":"https://stym06.github.io/posts/consistent-hashing/","summary":"The world works on distributed systems, and if there is one thing that is always happening is routing of requests. Be it how your Instagram posts go to that specific data-center or how the IPL matches being streamed are coming to us from which one of the global CDNs, all of this is a matter of effective choice of request-\u0026gt;server mapping essentially.\nWe have load balancers which do some of this.","title":"Consistent Hashing #️⃣"},{"content":"This is the first time I\u0026rsquo;m writing something on a blog of my own, guys. I must say that I never knew composing a blog using Markdown was really possible. I had set up so many blogging platforms over the years using every frontend and backend stuff I learned, but as Da Vinci had correctly said:\n\u0026ldquo;Simplicity is the ultimate sophistication.\u0026rdquo;\nSo, here we are, I\u0026rsquo;m using this neat little static site generator called Hugo to build my blog finally. Have even committed to writing one blog every Sunday.\nStay tuned on this space.\nThe plan is to make this place a collection of everything I love to explore on the internet and beyond.\nAdios, amigos! 🚀✨\nSystem.out.println(\u0026#34;Hello world\u0026#34;) ","permalink":"https://stym06.github.io/posts/hello-world/","summary":"This is the first time I\u0026rsquo;m writing something on a blog of my own, guys. I must say that I never knew composing a blog using Markdown was really possible. I had set up so many blogging platforms over the years using every frontend and backend stuff I learned, but as Da Vinci had correctly said:\n\u0026ldquo;Simplicity is the ultimate sophistication.\u0026rdquo;\nSo, here we are, I\u0026rsquo;m using this neat little static site generator called Hugo to build my blog finally.","title":"Hello World 👋🌍"},{"content":"Hey there, I\u0026rsquo;m Satyam, your friendly neighborhood software engineer by day and a nocturnal code wizard by night. 2am coffee? That\u0026rsquo;s when I\u0026rsquo;m in my element. Used to have a grudge against Java, but hey, now we\u0026rsquo;re buddies. And let\u0026rsquo;s not forget about Go, my new partner in crime.\nInterests 🎉 Programming Languages: Java, Go Hobbies: Watching football ⚽, diving into non-fiction and classic fiction books 📚 Gaming: FIFA sessions on my Playstation 🎮 Music: Rocking out to Pink Floyd 🎸 Chess: Taking down GMs on chess.com ♟️ ","permalink":"https://stym06.github.io/about/","summary":"Hey there, I\u0026rsquo;m Satyam, your friendly neighborhood software engineer by day and a nocturnal code wizard by night. 2am coffee? That\u0026rsquo;s when I\u0026rsquo;m in my element. Used to have a grudge against Java, but hey, now we\u0026rsquo;re buddies. And let\u0026rsquo;s not forget about Go, my new partner in crime.\nInterests 🎉 Programming Languages: Java, Go Hobbies: Watching football ⚽, diving into non-fiction and classic fiction books 📚 Gaming: FIFA sessions on my Playstation 🎮 Music: Rocking out to Pink Floyd 🎸 Chess: Taking down GMs on chess.","title":""}]
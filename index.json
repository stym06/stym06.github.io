[{"content":"The world works on distributed systems, and if there is one thing that is always happening is routing of requests. Be it how your Instagram posts go to that specific data-center or how the IPL matches being streamed are coming to us from which one of the global CDNs, all of this is a matter of effective choice of request-\u0026gt;server mapping essentially.\nWe have load balancers which do some of this. They try to route the incoming requests to one of the available servers in many of the available algorithms. We have distributed clusters of databases and servers all trying to do the same thing.\nWonder what they are using?\nConsistent Hashing.\nWait, what\u0026rsquo;s Hashing, first of all, and Consistent at that?\nLet\u0026rsquo;s dive in!\nLet\u0026rsquo;s say you have a bunch of keys you want to store and retrieve and you have a bunch of servers as well. For consistency, let\u0026rsquo;s assume we have 10 keys and only 3 servers\nWe can store these keys randomly, but we won\u0026rsquo;t be able to deterministically say which one of the server did my key go to, right? Ok, so we can store them in a round-robin fashion, sounds cool? Or cooler, we can encode the data into 8-bit and take the modulo of 3, so that we get a number betwen [1 -\u0026gt; 3], which gives us a server name. And since the encoding is also fixed, on retrieval of the key, we can again encode it, get the server name and do a fetch request for our key.\nAll fun till now. This works, Yes.\nBut imagine, if Server-2 goes down. We will have to move all our keys to one of the remaining ones, right? Or let\u0026rsquo;s say someone else also wants to send keys, we might need to add more servers. Well, for uniformity, we would need to relocate most of our keys to this new shiny server.\nTurns out this data movement operation will take all the time when doing upscaling and downnscaling. What\u0026rsquo;s a better way then?\nEnter Consistent Hashing!\nHere, we dont do the modulo thing to get the server id, but what we do is have a giant hash space where our servers reside with their hashkeys. And now, not taking the hash-collision approach of going to the index, we hash our key, and take a stroll to the right to find the first available hash. If we find it, that\u0026rsquo;s our server!\nLet\u0026rsquo;s implement this.\nOne way to implement this is using arrays and going to the right side of the array, but that takes O(n) in the worst case, so we just create a Sorted Map.\npublic class ConsistentHashing { private final MessageDigest md; private final TreeMap\u0026lt;Long, String\u0026gt; circle; private final int numReplicas; public ConsistentHashing(int numReplicas) throws NoSuchAlgorithmException { this.numReplicas = numReplicas; this.md = MessageDigest.getInstance(\u0026#34;SHA-256\u0026#34;); this.circle = new TreeMap\u0026lt;\u0026gt;(); } public void addServer(String key) { for(int i = 0; i \u0026lt; numReplicas; i++) { Long hash = generateHash(key + i); circle.put(hash, key); } } public void removeServer(String key) throws Exception { for(int i = 0; i \u0026lt; numReplicas; i++) { Long hash = generateHash(key + i); circle.remove(hash); } } public String getServer(String key) throws Exception { Long hash = generateHash(key); SortedMap\u0026lt;Long, String\u0026gt; tailMap = circle.tailMap(hash); Long firstServerTotheRightKey = tailMap.isEmpty() ? circle.firstKey() : tailMap.firstKey(); return circle.get(firstServerTotheRightKey); } private long generateHash(String key) { md.reset(); md.update(key.getBytes()); byte[] digest = md.digest(); long hash = ((long) (digest[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | ((long) (digest[2] \u0026amp; 0xFF) \u0026lt;\u0026lt; 16) | ((long) (digest[1] \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((long) (digest[0] \u0026amp; 0xFF)); return hash; } public static void main(String[] args) throws Exception { ConsistentHashing consistentHashing = new ConsistentHashing(10); //add servers and keys final List\u0026lt;String\u0026gt; servers = List.of(\u0026#34;s1\u0026#34;, \u0026#34;s2\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;s4\u0026#34;, \u0026#34;s5\u0026#34;); for(String server: servers) { consistentHashing.addServer(server); } //key for k1 System.out.println(\u0026#34;Current location of k1 is \u0026#34; + consistentHashing.getServer(\u0026#34;k1\u0026#34;)); //remove server s5 System.out.println(\u0026#34;Removing server s5\u0026#34;); consistentHashing.removeServer(\u0026#34;s5\u0026#34;); //key for k1 System.out.println(\u0026#34;New location of k1 is \u0026#34; + consistentHashing.getServer(\u0026#34;k1\u0026#34;)); } } ","permalink":"https://stym06.github.io/posts/consistent-hashing/","summary":"The world works on distributed systems, and if there is one thing that is always happening is routing of requests. Be it how your Instagram posts go to that specific data-center or how the IPL matches being streamed are coming to us from which one of the global CDNs, all of this is a matter of effective choice of request-\u0026gt;server mapping essentially.\nWe have load balancers which do some of this.","title":"Consistent Hashing #Ô∏è‚É£"},{"content":"This is the first time I\u0026rsquo;m writing something on a blog of my own, guys. I must say that I never knew composing a blog using Markdown was really possible. I had set up so many blogging platforms over the years using every frontend and backend stuff I learned, but as Da Vinci had correctly said:\n\u0026ldquo;Simplicity is the ultimate sophistication.\u0026rdquo;\nSo, here we are, I\u0026rsquo;m using this neat little static site generator called Hugo to build my blog finally. Have even committed to writing one blog every Sunday.\nStay tuned on this space.\nThe plan is to make this place a collection of everything I love to explore on the internet and beyond.\nAdios, amigos! üöÄ‚ú®\nSystem.out.println(\u0026#34;Hello world\u0026#34;) ","permalink":"https://stym06.github.io/posts/hello-world/","summary":"This is the first time I\u0026rsquo;m writing something on a blog of my own, guys. I must say that I never knew composing a blog using Markdown was really possible. I had set up so many blogging platforms over the years using every frontend and backend stuff I learned, but as Da Vinci had correctly said:\n\u0026ldquo;Simplicity is the ultimate sophistication.\u0026rdquo;\nSo, here we are, I\u0026rsquo;m using this neat little static site generator called Hugo to build my blog finally.","title":"Hello World üëãüåç"},{"content":"Hey there, I\u0026rsquo;m Satyam, your friendly neighborhood software engineer by day and a nocturnal code wizard by night. 2am coffee? That\u0026rsquo;s when I\u0026rsquo;m in my element. Used to have a grudge against Java, but hey, now we\u0026rsquo;re buddies. And let\u0026rsquo;s not forget about Go, my new partner in crime.\nInterests üéâ Programming Languages: Java, Go Hobbies: Watching football ‚öΩ, diving into non-fiction and classic fiction books üìö Gaming: FIFA sessions on my Playstation üéÆ Music: Rocking out to Pink Floyd üé∏ Chess: Taking down GMs on chess.com ‚ôüÔ∏è ","permalink":"https://stym06.github.io/about/","summary":"Hey there, I\u0026rsquo;m Satyam, your friendly neighborhood software engineer by day and a nocturnal code wizard by night. 2am coffee? That\u0026rsquo;s when I\u0026rsquo;m in my element. Used to have a grudge against Java, but hey, now we\u0026rsquo;re buddies. And let\u0026rsquo;s not forget about Go, my new partner in crime.\nInterests üéâ Programming Languages: Java, Go Hobbies: Watching football ‚öΩ, diving into non-fiction and classic fiction books üìö Gaming: FIFA sessions on my Playstation üéÆ Music: Rocking out to Pink Floyd üé∏ Chess: Taking down GMs on chess.","title":""}]